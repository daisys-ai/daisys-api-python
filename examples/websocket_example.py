import os, time
from typing import Optional
from daisys import DaisysAPI
from daisys.v1.speak import DaisysWebsocketGenerateError, HTTPStatusError, Status, TakeResponse

# Override DAISYS_EMAIL and DAISYS_PASSWORD with your details!
EMAIL = os.environ.get('DAISYS_EMAIL', 'user@example.com')
PASSWORD = os.environ.get('DAISYS_PASSWORD', 'pw')

# Please see tokens_example.py for how to use an access token instead of a password.

def main():
    with DaisysAPI('speak', email=EMAIL, password=PASSWORD) as speak:
        print('Found Daisys Speak API', speak.version())

        # A buffer to receive parts; we initialize with a single empty bytes()
        # because we will use it to accumulate chunks of the current wav file
        # there.  In total we will end with a list of wav files, one for each
        # part.  Parts are bits of speech, usually full sentences, that end with
        # silence.
        audio_wavs = [bytes()]

        # Assume at least one voice is available
        voice = speak.get_voices()[0]

        with speak.websocket(voice_id=voice.voice_id) as ws:
            # Flags we can use to only wait on our one take request; we wait
            # until the take is READY, and we also wait until we are done
            # receive all audio parts.
            done = False
            ready = False

            # Time the latency from when we submit the request until each part
            # is received.
            t0 = time.time()

            # The audio callback receives "parts" consisting of audio .wav files
            # with WAV headers on each part.  Depending on the stream settings,
            # the file may be divided into chunks, where chunk_id==None indicates
            # the last chunk of a part.  If audio==None, then no more parts will
            # arrive for that take_id.
            def audio_cb(request_id: int, take_id: str, part_id: int, chunk_id: Optional[int],
                         audio: Optional[bytes]):
                nonlocal done

                # Report timing info and function arguments
                print(f'[{time.time()-t0:0.3f}s] Received {part_id=} ({chunk_id=}) for {take_id=} '
                      'with audio length', len(audio) if audio else '(empty -- done receiving)')

                # We only requested one take_id; the take_id is generated by the
                # Daisys API, so we do not know it until the first status
                # message arrives.  Therefore we can check that the request_id
                # is the expected one.
                assert request_id == generate_request_id
                assert generated_take is None or  take_id == generated_take.take_id

                if audio is None:
                    # If stream is done for this part
                    if chunk_id in [0, None]:
                        # If we have any audio data, write out the last file
                        if len(audio_wavs[-1]) > 0:
                            with open(f'websocket_part{len(audio_wavs)}.wav', 'wb') as f:
                                f.write(audio_wavs[-1])
                                print(f'Read {len(audio_wavs[-1])} bytes of wav data, wrote "{f.name}".')
                        # Flag that we are done receiving audio
                        done = True

                    # If we are receiving the last chunk of a part
                    elif chunk_id > 0:
                        # Write out the part
                        with open(f'websocket_part{len(audio_wavs)}.wav', 'wb') as f:
                            f.write(audio_wavs[-1])
                            print(f'Read {len(audio_wavs[-1])} bytes of wav data, wrote "{f.name}".')

                        # Start a new part
                        audio_wavs.append(bytes())

                # Otherwise just append the chunk.
                else:
                    audio_wavs[-1] = audio_wavs[-1] + audio

            # The status callback is called every time the take's status
            # changes.  Here we use it to end the update loop.
            def status_cb(request_id: int, take: TakeResponse):
                nonlocal ready, generated_take
                assert request_id == generate_request_id
                generated_take = take
                print(take.status)
                if take.status == Status.READY:
                    ready = True

            # Submit a request to generate a take over the websocket connection.
            generate_request_id = ws.generate_take(
                voice_id=voice.voice_id,
                text='Hello from Daisys websockets! How may I help you?',
                status_callback=status_cb,
                audio_callback=audio_cb,
            )

            # Will be filled in by callbacks. On submitting the generate
            # request, we do not yet know what take_id will be assigned so we
            # must discover it by means of the status callback.
            generated_take = None

            # We loop on the websocket while waiting 5 seconds between updates,
            # and end when the take as been set to READY and all audio has been
            # received. This update waits 1 second by default, here we set to 5
            # seconds, but it can also wait forever by setting timeout to None
            # or be made a non-blocking operation by setting timeout to 0.
            # (Important: in async client, timeout=0 leads to TimeoutError, it
            # cannot be used for non-blocking operations with asyncio.)
            while not (ready and done) and (time.time() - t0) < 60:
                try:
                    ws.update(timeout=5)
                except DaisysWebsocketGenerateError as e:
                    # As opposed to other websocket errors, if a generate error
                    # occurs it does not necessarily mean we want to close the
                    # stream.
                    print(e)

                    # In this example, however, we actually do, because we only
                    # requested a single take, so stop here.
                    break

        # Delete the take
        if generated_take:
            print(f'Deleting take {generated_take.take_id}:', speak.delete_take(generated_take.take_id))

if __name__=='__main__':
    try:
        main()
    except HTTPStatusError as e:
        try:
            print(f'HTTP error status {e.response.status_code}: {e.response.json()["detail"]}, {e.request.url}')
        except:
            print(f'HTTP error status {e.response.status_code}: {e.response.text}, {e.request.url}')
